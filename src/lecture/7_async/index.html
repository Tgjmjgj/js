<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Asynchronous JavaScript</title>
	<meta name="description" content="Intruduction into asynchronous JS, AJAX requests, callbacks, promises and async functions">
	<meta name="keywords" content="js, async, ajax, fetch, callback, promise, await">
	<meta name="author" content="Pavel Karpovich">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	
	<link rel="stylesheet" href="../../css/custom.css" />
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? "../../css/print/pdf.css" : "../../css/print/paper.css";
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<script src="../../js/theme.js"></script>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Веб программирование. Фронтенд</h1>
                    <h3>Её величество Асинхронность</h3>
					<div>
						<p style="display: inline-block;">
							Карпович Павел / 
						</p>
						<a href="https://github.com/tgjmjgj" class="icon-button github">
							<i class="fa fa-github"></i><span></span>
						</a>
						<a href="https://facebook.com/paradox7master" class="icon-button facebook">
							<i class="fa fa-facebook"></i><span></span>
						</a>
					</div>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
            <section>
                <section>
                    <h1>Асинхронность</h1>
                    <p>
                        В JS постоянно приходится сталкиваться с асинхронностью, хотите вы того или не хотите.
                    </p>
                    <p>
                        Среда выполнения JavaScript построена на концепциях асинхронности: один единственный поток,
                        очередь сообщений, события и Event Loop, - всё это обеспечивает максимальную поддержку
                        асинхронного поведения.
                    </p>
                </section>
                <section>
                    <h2>Синхронный код</h2>
                    <p>
                        В синхронной программе, если две строки кода записаны друг за другом, вторая не может
                        начать выполняться, пока не закончит выполнение первая.
                    </p>
                    <p>
                        Это можно представить как очередь за билетами, например, в кино. Вы не можете заказать и купить
                        билет, пока все люди перед вами не закажут и не купять свои.
                    </p>
                </section>
                <section>
                    <h2>Асинхронный код</h2>
                    <p>
                        В асинхронной программе, у вам может быть 2 строчки кода, когда первая строчка запустит на
                        выполнение какое-либо действие, а вторая строчка будет выполнена раньше, чем первая закончит
                        выполнение своего действия.
                    </p>
                </section>
                <section>
                    <h2>Асинхронное поведение</h2>
                    <p>
                        Это можно представить, как посетителей ресторана. Вы можете заказать блюдо, и другие люди могут
                        заказать блюда. И чтобы сделать свой заказ, вам не нужно ждать, пока все посетители, заказавшие
                        что-либо перед вами, получат свои приготовленные блюда.
                    </p>
                    <p>
                        Если посетитель перед вами заказал рагу, а вы аж на 5 минут позже заказали стакан воды, это
                        не будет означать, что сначала будет выполнен заказ первого посетителя.
                    </p>
                    <p>
                        Порядок выполнения асинхронных задач не зависит от порядка их определения - только от их сложности и
                        времени выполнения.
                    </p>
                    <blockquote>
                        <span class="purple">Асинхронное</span>, или неблокирующее поведение - это когда программа не
                        ждёт завершения какого-либо действия, чтобы начать выполнять следующие.
                    </blockquote>
                </section>
                <section>
                    <h3>Асинхронность vs синхронность</h3>
                    <img src="img/Sync_async.png">
                </section>
                <section>
                    <h2>Многопоточность и асинхронность</h2>
                    <p>
                        <span class="purple">Многопоточность</span> (параллельное выполнение) и
                        <span class="purple">Асинхронность</span> (неблокируемость) - это разные понятия,
                        не зависящие друг от друга. 
                    </p>
                    <p>
                        Хотя они и решают одну и ту же задачу - максимально использовать имеющиеся ресурсы компьютера.
                    </p>
                </section>
                <section>
                    <h2>Задачи многопоточности</h2>
                    <p>
                        Многопоточность позволяет задействовать все ядра процессора - чтобы они не бездействовали и не
                        простаивали.
                    </p>
                    <p>
                        Многопоточность нужно применять, когда в программе присутствуют операции, не зависящие друг от друга,
                        и никак друг на друга не влияющие, которые можно распараллелить.
                    </p>
                    <blockquote>
                        Многопоточность - одновременное параллельное выполнение нескольких действий в программе.
                    </blockquote>
                    <p>
                        Возможность применения многопоточности (эффективного применения) зависит от конфигурации процессора,
                        на котором выполняется программа, т.е. от количества его физических и виртуальных ядер, а также
                        от задач, которые решает программа (можно ли их выполнять параллельно).
                    </p>
                </section>
                <section>
                    <h2>Задачи асинхронности</h2>
                    <p>
                        Асинхронность же позволяет максимально эффективно использовать ресурсы одного потока выполнения
                        (одного ядра процессора). Асинхронность - это отсутствие простоев в работе программы, устранение ситуаций, когда программа
                        ничего не выполняет, в ожидании завершения какого-либо действия.
                    </p>
                    <p>
                        Поэтому, как правило, асинхронность может использоваться только в том случае, когда программа
                        взаимодействует с каким-либо другим независимым компонентом (файловая система, сеть, другая программа),
                        т.к. обычно только при обращении к стороннему ресурсу, и ожидании от него ответа, в программе
                        может произойти простой.
                    </p>
                    <p>
                        Значит, асинхронность можно использовать далеко не в любой ситуации. А только (почти) когда операция
                        вызывает простой (т.е. блокирует выполнение программы).
                    </p>
                </section>
                <section>
                    <h2>Пример</h2>
                    <p>
                        Вернёмся к примеру с очередью за билетами.
                    </p>
                    <p>
                        Если все люди стоят в общей очереди и ждут, когда придёт их черёд - это синхронный и однопоточный
                        процесс.
                    </p>
                    <p>
                        Если открыто несколько касс, и очередей несколько - это синхронный и многопоточный процесс.
                    </p>
                    <p>
                        Если люди быстро говорят кассиру, что им нужен билет, и уходят заниматься своими делами, не дожидаясь
                        пока кассир зарегистрирует место и всё оформит, и когда вся очередь быстро рассосётся, он станет
                        оформлять билеты, отправляя их по электронной почте покупателям - то это процесс асинхронный.
                    </p>
                </section>
                <section>
                    <h3>Многопоточность + асинхронность</h3>
                    <p>
                        Программа может быть многопоточной и синхронной, однопоточной и
                        асинхронной, или и то, и другое сразу - между многопоточностью и асинхронностью нет зависимости.
                    </p>
                    <p>
                        В большинстве языков программирования от вас зависит, как писать код - использовать
                        многопоточность или не использовать, применять асинхронность или не применять.
                    </p>
                    <p>
                        Но в JavaScript вам выбора не дают - программа на JS всегда <u>однопоточна и асинхронна</u>.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Примеры</h2>
                    <p>
                        Конечно, мы опять начнём с функции <span class="blue">setTimeout()</span> - это самый простой
                        и наглядный пример асинхронного поведения в JavaScript.
                    </p>
                    <pre>
                        <code class="js">
// 1 - Выведет на консоль "Hello."
console.log("Hello.");
// 3 - Выведет на консоль "Goodbye" через 2 секунды
setTimeout(function() {
    console.log("Goodbye!");
}, 2000);
// 2 - Выведет на консоль "Hello again!"
console.log("Hello again!");
                        </code>
                    </pre>
                    <p>
                        Если бы мы писали аналог подобной программы на языке программирования, где присутствуют
                        синхронные операции (например, C# со Sleep на 2 секунды), то после вывода "Hello.",
                        программа бы приостановила своё выполнение на 2 секунды, а затем вывела бы подряд
                        строки "Goodbye!" и "Hello again!".
                    </p>
                </section>
                <section>
                    <h2>JavaScript - асинхронный</h2>
                    <blockquote>
                        В JavaScript отсутствует всякая возможность писать синхронный код.
                    </blockquote>
                    <p>
                        Разумеется, это относится только к тем местам, где может стоять выбор между синхронным
                        выполнением и асинхронным выполнением.
                    </p>
                    <p>
                        Т.е. в JS, например, нет синхронных таймеров (как Sleep), и любые операции чтения/записи,
                        или любые запросы к другим ресурсам/системам всегда работают асинхронно. 
                    </p>
                    <p>
                        Не существует способа заблокировать выполенние программы на JavaScript. Кроме бесконечного
                        цикла, конечно (и противного alert).
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Ассоциация</h2>
                    <p>
                        Представим такую ситуацию, что нужно позвонить человеку, чтобы узнать у него
                        какую-нибудь информацию, например, его паспортные данные. Синхронный вариант такого
                        действия - это продолжать висеть на телефоне и ждать, пока собеседник будет искать
                        свой паспорт, пока он не назовёт вам запрошенные данные.
                    </p>
                    <p>
                        Программно это можно записать как следующий блок кода:
                    </p>
                    <pre>
                        <code class="js">
// Звоним Алексу и ждём, пока он не скажет свои паспортные данные
const passportData = callToRecievePassportData("Алекс");
// Дождавшись, выводим их
console.log("Паспортные данные Алекса: " + passportData);
// И приступаем к другой работе
doWork();
                        </code>
                    </pre>
                    <p>
                        Т.е. это стандартные код, простой вызов функции, как мы всегда это делали. Потому что мы
                        всегда писали синхронный код.
                    </p>
                </section>
                <section>
                    <h2>Возврат значения асинхроннного выражения</h2>
                    <p>
                        Но JavaScript не даст сделать такую операцию синхронно. Как бы это действие выглядело в
                        асинхронном формате?
                    </p>
                    <p>
                        Вы бы позвонили человеку, и сказали, чтобы он нашёл свои паспортные данные и тогда перезвонил
                        вам, чтобы сообщить их. И не дожидаясь, вы бы закончили разговор, и стали заниматься своими делами. 
                    </p>
                    <p>
                        Но как тогда записать такой код? Старая версия больше не будет работать.
                    </p>
                    <pre>
                        <code class="js">
// Звоним Алексу и говорим ему, чтобы он перезвонил с результатом
// Мы больше не можем получить результат через возвращаемое значение -
// Значение здесь не возвращается, оно будет выдано нам в будущем
callToRecievePassportData("Алекс");
// Алекс ищет паспорт, а мы продолжаем выполнять следующие команды
// Т.е. занимаемся своими делами
doWork();
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Коллбэк</h2>
                    <p>
                        Вот здесь и появляется коллбэк (<span class="purple">callback</span>), или обратный вызов - 
                        это то действие, которое нужно выполнить после завершения асинхронной операции.
                    </p>
                    <p>
                        Асинхронные действия не возвращают результата в привычном для программирования понимании,
                        через возвращаемое значение.
                    </p>
                    <p>
                        Вместо этого нужно задавать действие, которое должно выполниться, когда асинхронная операция
                        будет завершена, и в нём уже оперировать с результатом операции.
                    </p>
                    <p>
                        В программировании это действие задаётся как функция, передающаяся в качестве параметра
                        в асинхронную функцию - т.е. коллбэк.
                    </p>
                </section>
                <section>
                    <h2>Коллбэк в асинхронной функции</h2>
                    <p>
                        Тогда рассмотренный пример с паспортными данными, в асинхронном варианте будет выглядеть
                        следующим образом:
                    </p>
                    <pre>
                        <code class="js">
// Звоним Алексу и говорим ему, чтобы он перезвонил с результатом
callToRecievePassportData("Алекс", function(passportData) {
    // Что будем делать, когда Алекс нам перезвонит и скажет свои данные
    // Выведем их на консоль
    console.log("Паспортные данные Алекса: " + passportData);
});
// Алекс ищет паспорт, а мы продолжаем выполнять следующие команды
// Т.е. занимаемся своими делами
doWork();
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Значение коллбэка</h2>
                    <blockquote>
                        Коллбэк - это единственный способ обработки результата асинхронной функции.
                    </blockquote>
                    <p>
                        В JavaScript коллбэки асинхронных функций работают как обработчики событий завершения
                        операции. Т.е. можно считать, что записывая коллбэк, вы назначаете вашу функцию в качестве
                        обработчика для события выполнения этого асинхронного действия.
                    </p>
                    <p>
                        Это значит, что как только браузер зафиксирует, что асинхронная операция завершилась (например, 
                        время таймеро истекло, или другая программа выдала ответ на запрос браузера), он поместит в
                        <u>очередь сообщений</u> запись с функцией вашего коллбэка. И она будет передана на выполнение
                        <u>циклом событий</u>, как только освободится <u>стек вызова</u>.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Главная звезда асинхронности</h2>
                    <p>
                        Но где реальные примеры асинхронности в JavaScript? В каких местах она применяется больше всего?
                    </p>
                    <p>
                        <span class="blue">setTimeout()</span> и <span class="blue">setInterval()</span>, конечно,
                        являются примерами асинхронных операций, но это не то, что встречается в коде повсеместно
                        и используется на каждом шагу.
                    </p>
                    <p>
                        Основной источник асинхронного кода в JS - это <span class="purple">AJAX</span>.
                    </p>
                </section>
                <section>
                    <h1>AJAX</h1>
                </section>
            </section>
		</div>
	</div>

	<aside id="presentable-icon" class="cpp">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x controls"></i>
		</a>
	</aside>
	<aside id="presentable-icon-close">
		<a title="К списку материалов" href="../../index.html#/1">
			<i class="fa fa-times fa-2x controls"></i>
		</a>
	</aside>
	<aside id="presentable-theme-picker">
		<div id="hidden-bar" class="invisible">
			<div>
				<div data-theme="beige" class="theme-circle theme-beige"></div>
				<div data-theme="black" class="theme-circle theme-black"></div>
				<div data-theme="blood" class="theme-circle theme-blood"></div>
				<div data-theme="league" class="theme-circle theme-league"></div>
				<div data-theme="moon" class="theme-circle theme-moon"></div>
				<div data-theme="night" class="theme-circle theme-night"></div>
				<div data-theme="serif" class="theme-circle theme-serif"></div>
				<div data-theme="simple" class="theme-circle theme-simple"></div>
				<div data-theme="sky" class="theme-circle theme-sky"></div>
				<div data-theme="solarized" class="theme-circle theme-solarized"></div>
				<div data-theme="white" class="theme-circle theme-white"></div>
			</div>
		</div>
		<div id="selected-theme" class="theme-circle"></div>
	</aside>

	<script src="../../js/bundle.min.js"></script>
</body>

</html>