<!doctype html>
<html lang="ru">

<head>
	<meta charset="utf-8">
	<title>Jest</title>
	<meta name="description" content="JavaScript testing with Jest framework">
	<meta name="keywords" content="js, testing, unit-test, jest">
	<meta name="author" content="Pavel Karpovich">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="../../css/bundle.min.css">
	
	<link rel="stylesheet" href="../../css/custom.css" />
	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? "../../css/print/pdf.css" : "../../css/print/paper.css";
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>

	<!--[if lt IE 9]>
		<script src="../../js/html5shiv.min.js"></script>
	<![endif]-->
</head>

<body>
	<script src="../../js/theme.js"></script>
	<div class="reveal">
		<div class="slides">
			<section>
                <section>
                    <h1>Тестирование</h1>
                    <h3>Юнит тесты на JavaScript</h3>
					<div>
						<p style="display: inline-block;">
							Карпович Павел / 
						</p>
						<a href="https://github.com/tgjmjgj" class="icon-button github">
							<i class="fa fa-github"></i><span></span>
						</a>
						<a href="https://facebook.com/paradox7master" class="icon-button facebook">
							<i class="fa fa-facebook"></i><span></span>
						</a>
					</div>
                </section>
				<section>
					<h2>Содержание лекции</h2>
					<nav id="presentable-toc" class="table-content"></nav>
				</section>
			</section>
            <section>
                <section>
                    <h1>Тестирование</h1>
                    <p>
                        Ни один серьёзный проект не обходится без тестирования.
                    </p>
                    <p>
                        Бывает тестирование методом чёрного ящика - когда тестируется конечный
                        интерфейс продукта без доступа и знания исходного кода. 
                    </p>
                    <p>
                        И бывает тестирование методом белого ящика - когда тестируется исходный код
                        программной системы.
                    </p>
                    <p>
                        Тестирование методом чёрного ящика обычно занимаются тестировщики.
                    </p>
                    <p>
                        Тестированием белого ящика - программисты. И как раз о таком тестировании мы сейчас и поговорим.
                    </p>
                </section>
                <section>
                    <h2>Юнит тесты</h2>
                    <p>
                        Любому проекту нужны тесты. Если заглянуть, например, на GitHub - в каждом мало-мальски 
                        объёмном и поддерживаемом проекте можно будет найти папку с тестами.
                    </p>
                    <p>
                        Это - <span class="purple">Юнит-тесты</span>, - цемент, скрепляющий весь код и не дающий
                        ему развалиться.
                    </p>
                </section>
                <section>
                    <h>Юнит-тесты</h1>
                    <blockquote>
                        <span class="purple">Юнит-тесты,</span> или Модульные тесты - тесты, которые проверяют
                        работоспособность отдельных функций в программного коде системы.
                    </blockquote>
                    <p>
                        Юнит-тесты пишет программист, а не тестировщик.
                    </p>
                    <p>
                        Когда программист пишет код, вместе с этим кодом он должен писать для него юнит-тесты.
                        Юнит-тесты проверяют работоспособность написанного кода.
                    </p>
                    <p>
                        И это не что-то дополнительное или необязательное. Это - обязанность любого (практически)
                        программиста, над каким бы проектом он не работал.
                    </p>
                    <p>
                        Если вы пишете код для реального проекта, который нужно будет поддерживать и обновлять, -
                        вам нужны будут юнит-тесты.
                    </p>
                </section>
                <section>
                    <h2>Юнит-тесты</h2>
                    <p>
                        Любой код состоит из набора функций, ну или объектов с методами. И юнит тесты позволяют 
                        точечно оценить работоспособность функций, и сказать, где и что работает не по плану.
                    </p>
                    <p>
                        Это чрезвычайно важно для <span class="purple">Регрессионного тестирования</span> - когда
                        вы обновляете часть кода, и нужно убедиться, что ничего из того, что работало раньше, не
                        поломалось.
                    </p>
                    <p>
                        Или, вот ещё один пример, когда у вас относительно большая кодовая база, например, несколько
                        десятков тысяч строк, вы можете долгое время не работать над какой-то частью программы, 
                        и забыв, как работает код, вернуться, и наломать дров. В таком случае, юнит тесты 
                        сразу дадут знать, что именно, и в каких местах, пошло не так. 
                    </p>
                </section>
                <section>
                    <h3>График</h3>
                    <img src="img/graph.png" alt="">
                </section>
            </section>
            <section>
                <section>
                    <h2>Юнит тесты</h2>
                    <p>
                        В первую очередь юнит тесты используются для тестирования логики. Для тестирования интерфейса
                        пользователя существуют другие виды тестов.
                    </p>
                    <p>
                        А в веб программировании вся основная логика обычно располагается на бэкенде - серверной части
                        приложения. Поэтому юнит тесты не так активно используются во фронтенд разработке.
                    </p>
                    <p>
                        Но всё равно есть возможности писать юнит тесты для кода, предназначенного для браузера, и 
                        мы сейчас научимся это делать.
                    </p>
                </section>
                <section>
                    <h2>Юнит тесты в JavaScript</h2>
                    <p>
                        В JS существует множество библиотек (фреймворков) для написания юнит тестов:
                    </p>
                    <ul>
                        <li>Jest</li>
                        <li>Mocha</li>
                        <li>Jasmine</li>
                        <li>Karma</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Jest</h2>
                    <p>
                        Jest - самый многофункциональный и универсальный фреймворк тестирования.
                    </p>
                    <p>
                        Многие другие фреймворки тестирования сосредоточены на каком-то одном аспекте юнит тестов,
                        и для добавления новой функциональности, которая практически всегда бывает нужна,
                        требуется устанавливать дополнительные пакеты.
                    </p>
                    <p>
                        В Jest-е же есть всё и сразу.
                    </p>
                    <p>
                        Поэтому мы будем рассматривать юнит тесты именно с этим фреймворком.
                    </p>
                </section>
                <section>
                    <h3>Установка Jest 1</h3>
                    <p>
                        Чтобы установить Jest, понадобится установленный NodeJS на компьютере. А также пакетный менеджер
                        NodeJS - npm, идущий в комплекте со средой.
                    </p>
                    <p>
                        Также проект, к которому нужно подключить Jest, должен являться пакетом NodeJS, т.е. содержать
                        файл <i>package.json</i>.
                    </p>
                    <p>
                        Создать этот файл можно консольной командой:
                    </p>
                    <pre>
                        <code class="bash">
npm init
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Установка Jest 2</h3>
                    <p>
                        Устанавливается Jest с помощью команды:
                    </p>
                    <pre>
                        <code class="bash">
npm i -D jest
npm i -D @types/jest
                        </code>
                    </pre>
                    <p>
                        Для того, чтобы его можно было удобно запускать из консоли, нужно прописать соответствующую
                        задачу в разделе scripts в файле package.json:
                    </p>
                    <pre>
                        <code class="json">
"scripts": {
    "test": "jest"
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Необходимые зависимости</h2>
                    <p>
                        Чтобы тесты могли работать с файлами модулей, необходимо дополнительно установить еще
                        и эти пакеты:
                    </p>
                    <pre>
                        <code class="bash">
npm i -D @babel/core
npm i -D @babel/preset-env
                        </code>
                    </pre>
                    <p>
                        Затем, в корне проекта создать файл .babelrc, и написать в нём:
                    </p>
                    <pre>
                        <code class="json">
{
    "env": {
        "test": {
            "presets": ["@babel/preset-env"]
        }
    }
}
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Запуск</h2>
                    <p>
                        Чтобы запустить все юнит тесты на исполнение, нужно выполнить команду:
                    </p>
                    <pre>
                        <code class="bash">
npm test
                        </code>
                    </pre>
                    <p>
                        Или установить расширение для VS Code для Jest:
                    </p>
                    <img src="img/vscode-jest.png">
                </section>
                <section>
                    <h2>Файлы с тестами</h2>
                    <p>
                        По умолчанию, Jest ищет все файлы, название которых заканчивается на <i>test.js</i>.
                    </p>
                    <p>
                        Например, если у вас есть файл index.js, то тесты для функций этого файла обычно выносят
                        в файл index.test.js. Или создают отдельную директорию test в корне проекта, куда
                        размещают все файлы тестов.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Юнит тесты</h2>
                    <p>
                        Но есть одна важная особенность. Юнит тесты обычно запускаются в среде NodeJs, а не в браузере,
                        даже если это браузерный JavaScript.
                    </p>
                    <p>
                        В браузере запускают другой тип тестов - функциональные, но про них будет следующая лекция.
                    </p>
                </section>
                <section>
                    <h2>Правила написания функций</h2>
                    <p>
                        Для того, чтобы код было удобно тестировать, нужно стараться как можно больше использовать
                        <span class="purple">чистые функции</span>.
                    </p>
                    <blockquote>
                        <span class="purple">Чистые функции</span> - функции, никак не изменяющие общего состояния
                        системы и не имеющие побочных эффектов. Для одного и того же набора входных параметров
                        функция всегда должна возвращать одинаковый результат.
                    </blockquote>
                    <p>
                        Более подробно о чистых функциях можно почитать <a href="https://habr.com/ru/post/437512/">здесь</a>.
                    </p>
                </section>
                <section>
                    <h2>Суть</h2>
                    <blockquote>
                        Главное правило, которого следует придерживаться в браузерном JS - всегда отделять 
                        чистую логику от кода изменения интерфейса (HTML страницы).
                    </blockquote>
                </section>
            </section>
            <section>
                <section>
                    <h2>Модули</h2>
                    <p>
                        Тесты всегда пишут в отдельных файлах, поэтому возникает необходимость в получении кода из
                        исходных файлов. Нужно ведь как-то обращаться к функциям, которые собираетесь тестировать.
                    </p>
                    <p>
                        Обычные скриптовые файлы, которые подключаются к HTML странице, нельзя подключить к другому
                        JavaScript файлу. Ведь тесты запускаются в NodeJS, где никакого HTML документа нет.
                    </p>
                    <p>
                        И получается, что нужно так писать код, чтобы файлы можно было подключить и к HTML странице,
                        и к другому файлу в NodeJS.
                    </p>
                    <p>
                        И этого можно добиться, структурировав файлы в модули ES6.
                    </p>
                </section>
                <section>
                    <h2>Модули ES6</h2>
                    <blockquote>
                        <span class="purple">Модули</span> - способ структуризации и группировки JavaScript кода,
                        когда каждый отдельный файл JS предоставляет свое собственное пространство имён с 
                        приватными и публичными элементами.
                    </blockquote>
                    <p>
                        Модули - это те же файлы JavaScript, только с небольшими дополнениями в коде, и альтернативным
                        способом подключения.
                    </p>
                </section>
                <section>
                    <h2>Закрытые модули</h2>
                    <p>
                        При обычном подключение JS файлов, все глобально объявленные переменные и функции попадают
                        в общий глобальный контекст.
                    </p>
                    <p>
                        При использовании модулей же такого не происходит - в глобальный контекст ничего не добавляется.
                        У каждого модуля своё закрытое пространство имён.
                    </p>
                    <p>
                        По умолчанию, в модуле все переменные и функции закрыты. Это значит, что к ним никак нельзя
                        получить доступ из других файлов/модулей.
                    </p>
                </section>
                <section>
                    <h2>Экспорт</h2>
                    <p>
                        В модулях можно помечать, к каким элементам нужно дать возможность обращаться из других модулей.
                    </p>
                    <p>
                        Это называется <span class="purple">Экспортом</span>.
                    </p>
                    <p>
                        Каждый модуль может экспортировать свои элементы, которые должны быть публичными.
                    </p>
                    <p>
                        Например, если в модуле (файле) у вас описано 10 функций, и вы экспортируете одну из них - главную,
                        то только эту функцию можно будет использовать в других модулях (файлах).
                    </p>
                </section>
                <section>
                    <h2>Импорт</h2>
                    <p>
                        Подключение в один модуль экспортируемых элементов из другого модуля называется
                        <span class="purple">Импортом</span>.
                    </p>
                    <p>
                        Т.е. сам по себе экспорт не делает глобально видимыми экспортируемые объекты. Экспорт просто позволяет
                        делать импорт.
                    </p>
                    <p>
                        Если вы хотите что-то из одного файла использовать в другом файле, то в файле-источнике нужно
                        прописать экспорт нужного элемента, а в другом файле сделать его импорт.
                    </p>
                </section>
                <section>
                    <h2>Ключевое слово export</h2>
                    <p>
                        Для того, чтобы отметить элемент, как экспортируемый, к нему в начале, перед определением,
                        нужно прописать ключевое слово <span class="blue">export</span>.
                    </p>
                    <p>
                        Хоть можно экспортировать и переменные, рекомендуется экспортировать только функции или классы.
                    </p>
                    <pre>
                        <code class="js">
export function myFunc(arg1) {
    console.log('I work with ' + arg1);
    return 0;
}

export class SomeClass {
    constructor() {
        console.log('Constructing an instance of the class SomeClass');
    }
}

export const key = '6723tgfbvysdbcswygr23gd8237Tr3rwrr';
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Комбинированный экспорт</h2>
                    <p>
                        Можно записывать экспорт иначе, не прописывая ключевое слово <span class="blue">export</span>
                        по всему коду, а написав весь перечень экспортируемых объектов за один раз:
                    </p>
                    <pre>
                        <code class="js">
function myFunc(arg1) {
    console.log('I work with ' + arg1);
    return 0;
}

class SomeClass {
    constructor() {
        console.log('Constructing an instance of the class SomeClass');
    }
}

const key = '6723tgfbvysdbcswygr23gd8237Tr3rwrr';

// Комбинированный список экспортируемых объектов
export { myFunc, SomeClass, key };
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Ключевое слово import</h2>
                    <p>
                        Подключение экспортируемых элементов осуществляется с помощью ключевого слова
                        <span class="blue">import</span>. Обычно это прописывается в самом начале файла.
                    </p>
                    <p>
                        Есть несколько вариаций записи этой команды.
                    </p>
                </section>
                <section>
                    <h2>Выборочный импорт</h2>
                    <p>
                        Можно импортировать конкретные объекты по имени, тогда это записывается следующим образом:
                    </p>
                    <pre>
                        <code class="js">
// Импорт функции myFunc и класса SomeClass из другого модуля (файла) module-file-name.js
import {myFunc, SomeClass} from './module-file-name.js';
                        </code>
                    </pre>
                    <p>Тогда объекты будут доступны по прописанным именам:</p>
                    <pre>
                        <code class="js">
const retVal = myFunc(123);
const instance = new SomeClass();
                        </code>
                    </pre>
                    <p>
                        Суть этого способа в том, что мы импортируем не всё, что экспортирует модуль, а только то,
                        что нам нужно.
                    </p>
                </section>
                <section>
                    <h2>Полный импорт</h2>
                    <p>
                        Также можно импортировать весь модуль целиком:
                    </p>
                    <pre>
                        <code class="js">
// Импортируем всё в объект myModule из модуля (файла) module-file-name.js
import * as myModule from './module-file-name.js';
                        </code>
                    </pre>
                    <p>
                        Тогда доступ к импортированным элементам будет осуществляться через ключи (свойства)
                        объекта импорта:
                    </p>
                    <pre>
                        <code class="js">
const retVal = myModule.myFunc(123);
const instance = new myModule.SomeClass();
let a = 'key string: ' + myModule.key;
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Подключение модуля к странице</h2>
                    <p>
                        Для того, чтобы подключить к HTML странице JavaScript файл, являющийся модулем (а модулем
                        будет считаться любой JavaScript файл, в котором присутствуют команды
                        <span class="blue">import</span> или <span class="blue">export</span>), нужно в теге
                        <i>script</i> использовать дополнительный атрибут <i>type="module"</i>.
                    </p>
                    <pre>
                        <code class="js">
&lt;script src="js/module-file-name.js" type="module"&gt;&lt;/script&gt;
                        </code>
                    </pre>
                    <p>
                        Модули, которые используются в других модулях (через import), дополнительно подключать к
                        HTML документу не нужно. Обычно подключается лишь один главный модуль, а через него уже
                        идут связи с остальными.
                    </p>
                </section>
                <section>
                    <h2>Связывание модулей</h2>
                    <img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/10_construction.png">
                </section>
            </section>
            <section>
                <section>
                    <h2>Jest</h2>
                    <p>
                        Jest - наиболее объёмный и функциональный фреймворк.
                    </p>
                    <p>
                        В нём из коробки идут все необходимые компоненты:
                    </p>
                    <ul>
                        <li>Богатый набор матчеров</li>
                        <li>Моки для функций и модулей</li>
                        <li>Спаи</li>
                        <li>Интеграции с babel, rewire, jsdom и др.</li>
                        <li>Множество CLI опций</li>
                        <li>Метрики покрытия тестами</li>
                    </ul>
                </section>
                <section>
                    <h2>Первый тест</h2>
                    <p>
                        Простейший пример теста:
                    </p>
                    <pre>
                        <code class="js">
test('Два плюс два равно четыре', function() {
    expect(2 + 2).toBe(4);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Структура теста</h2>
                    <p>
                        Любой тест задаётся вызовом функции <span class="blue">test</span>, или функции
                        <span class="blue">it</span> - это синонимы.
                    </p>
                    <p>
                        Эта функция принимает первым параметром строку - описание теста. Здесь принято кратко,
                        в двух словах, описывать, что проверяет данный тест. 
                    </p>
                    <pre>
                        <code class="js">
test('Что проверяем', function() {
    // Тело теста
});
// или
it('Что проверяем', function() {
    // Тело теста
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Triple A</h2>
                    <p>
                        Стандарт оформления юнит тестов - схема ААА, когда тело теста условно разделяется на три части:
                    </p>
                    <ul>
                        <li>Arrange - назначение. Создание всех необходимых переменных и объектов для выполнения проверяемого действия.</li>
                        <li>Act - действие. Выполнение тестируемого действия.</li>
                        <li>Assert - проверка. Сравнение ожидаемого результата тестируемого действия с фактическим результатом.</li>
                    </ul>
                    <pre>
                        <code class="js">
test('Что тестируем', function() {
    // Arrange

    // Act

    // Assert
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Пример ААА</h2>
                    <p>
                        Тестируем функцию <i>Math.sqrt()</i>:
                    </p>
                    <pre>
                        <code class="js">
test('Корень из 36 это 6', function() {
    // Arrange - создаём переменные
    const number = 36;
    const expectedSqrt = 6;
    // Act - тестируемое действие и получение реального результата
    const realSqrt = Math.sqrt(number);
    // Assert - сравнение, совпал ли ожидаемый и реальный результат
    expect(realSqrt).toBe(expectedSqrt);
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Матчеры</h2>
                    <p>
                        Результат любого теста отталкивается от какой-либо специфической проверки, от сравнения ожидаемого
                        результата и фактического результата. И для выполнения этих проверок используются
                        <span class="purple">Матчеры</span>.
                    </p>
                    <p>
                        Собственно, <span class="purple">Матчеры</span> - это категория функций и объектов в библиотеке
                        тестирования, которые используются для написания проверок в тесте (секции Assert).
                    </p>
                    <p>
                        Любой тест опирается на какой-нибудь матчер. Не может быть теста без матчера.
                    </p>
                </section>
                <section>
                    <h2>Матчеры в Jest</h2>
                    <p>
                        Все матчеры в Jest прописываются с помощью функции <span class="blue">expect()</span>.
                    </p>
                    <p>
                        Например, самая стандартная проверка на равенство:
                    </p>
                    <pre>
                        <code class="js">
expect(8 * 6).toBe(48);
                        </code>
                    </pre>
                    <p>
                        И такой синтаксис всегда: вызывается функция <span class="blue">expect()</span>, в неё передаётся
                        <u>полученный результат</u>, а затем у вернувшегося объекта вызывается один из методов (здесь - toBe)
                        проверки, в котором уже указывается <u>ожидаемый результат</u>.
                    </p>
                    <p>
                        Вызовов функции <span class="blue">expect()</span> может быть несколько в тесте, но лучше
                        без необходимости не использовать больше одного.
                    </p>
                </section>
                <section>
                    <h2>Функции-матчеры</h2>
                    <p>
                        В объекте, который возвращает функция <span class="blue">expect()</span>, целая куча разных
                        матчеров на любую ситуацию.
                    </p>
                    <p>
                        Полный их список можно найти <a href="https://jestjs.io/docs/en/expect">в официальной документации</a>.
                    </p>
                    <p>
                        Функции матчеры называются таким образом, чтобы из строки кода проверки 
                        формировалось практически полноценное английское предложение.
                    </p>
                    <p>
                        Например:
                    </p>
                    <pre>
                        <code class="js">
// Ожидаем, что строка будет иметь длину 7
expect(string).toHaveLength(7);
// Ожидаем, что число будет больше или равно 25
expect(number).toBeGreaterThanOrEqual(25);
// Ожидаем, что имя не будет содержать символа '-'
expect(name).not.toContain('-');
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Виды матчеров</h2>
                    <p>
                        Условно, все функции-матчеры можно разбить на следующие категории:
                    </p>
                    <ul>
                        <li>Проверки на равенство</li>
                        <li>Проверки для чисел</li>
                        <li>Проверки для строк</li>
                        <li>Проверки для коллекций</li>
                        <li>Проверки объектов</li>
                        <li>Проверки исключений</li>
                        <li>Проверки снапшотов</li>
                        <li>Проверки моков и спаев</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Проверки на равенство</h2>
                    <p>
                        Самая основная проверка, которая используется в 3/4 тестов - <span class="blue">toBe()</span>.
                    </p>
                    <p>
                        <span class="blue">toBe()</span> сравнивает полученное значение с ожидаемым, по подобию
                        оператора ===. Т.е. строгое сравнение для примитивов, и ссылочное сравнение для объектов.
                    </p>
                    <pre>
                        <code class="js">
const item = {
    name: 'Сливочное масло',
    mass: 250,
};
test('Весит 250 грамм', function() {
    expect(item.mass).toBe(250);
});
test('Называется "Сливочное масло"', () => {
    expect(item.name).toBe('Сливочное масло');
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>toBe - по ссылке</h2>
                    <p>
                        Матчер <span class="blue">toBe()</span> не подойдёт, если нужно сравнить по значению 
                        два объекта с разными ссылками:
                    </p>
                    <pre>
                        <code class="js">
function getCart() {
    return {
        name: 'Сливочное масло',
        mass: 250,
    };
}
test('В корзине находится указанная пачка масла', function() {
    const expectedItem = {
        name: 'Сливочное масло',
        mass: 250,
    };
    const cartItem = getCart();
    // Упсс... Тест не проходит
    expect(cartItem).toBe(expectedItem);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Матчер toEqual</h2>
                    <p>
                        Для сравнения объектов по значению нужно использовать матчер <span class="blue">toEqual()</span>.
                    </p>
                    <p>
                        <span class="blue">toEqual()</span> рекурсивно сравнивает все ключи и значения между двумя объектами.
                    </p>
                    <pre>
                        <code class="js">
function getCart() {
    return {
        name: 'Сливочное масло',
        mass: 250,
    };
}
test('В корзине находится указанная пачка масла', function() {
    const expectedItem = {
        name: 'Сливочное масло',
        mass: 250,
    };
    const cartItem = getCart();
    // Все работает!
    expect(cartItem).toEqual(expectedItem);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Сравнения с константами</h2>
                    <p>
                        В Jest есть много матчеров, которые сравнивают полученный результат с какими-то
                        константными значениями. Можно обойтись и без них, используя универсальный 
                        <span class="blue">toBe()</span>, но они позволяют упростить чтение теста и
                        сделать код чище.
                    </p>
                    <p>
                        Например, матчер <span class="blue">toBeFalsy()</span>:
                    </p>
                    <pre>
                        <code class="js">
expect(1 === 8).toBeFalsy();
                        </code>
                    </pre>
                    <p>
                        То же самое можно написать с использованием стандартного <span class="blue">toBe()</span>:
                    </p>
                    <pre>
                        <code class="js">
expect(1 === 8).toBe(false);
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Специфичные матчеры</h2>
                    <p>
                        К подобным матчерам относятся:
                    </p>
                    <ul>
                        <li><span class="blue">toBeDefined()</span> - что угодно, кроме undefined</li>
                        <li><span class="blue">toBeFalsy()</span> - равно false</li>
                        <li><span class="blue">toBeNull()</span> - равно null</li>
                        <li><span class="blue">toBeTruthy()</span> - равно true</li>
                        <li><span class="blue">toBeUndefined()</span> - равно undefined</li>
                        <li><span class="blue">toBeNaN()</span> - равно NaN</li>
                    </ul>
                </section>
                <section>
                    <h3>Пример тестирования функции деления</h3>
                    <pre>
                        <code class="js">
function divide(a, b) {
    return a / b;
}

test('Целочисленное деление', function() {
    const a = 32;
    const b = 2;
    const expected = 16;
    const result = divide(a, b);
    expect(result).toBe(expected);
});
test('Деление нуля', function() {
    const a = 0;
    const b = 2;
    const expected = 0;
    const result = divide(a, b);
    expect(result).toBe(expected);
});
test('Деление на ноль', function() {
    const a = 32;
    const b = 0;
    const expected = Infinity;
    const result = divide(a, b);
    expect(result).toBe(Infinity);
});
test('Деление непонятно чего непонятно на что', function() {
    const a = [1,2,3,4,5,6];
    const b = ',';
    const result = divide(a, b);
    expect(result).toBeNaN();
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Отрицание матчера</h2>
                    <p>
                        Любой матчер можно обратить. Т.е. вместо матчера "должно быть равно" сделать матчер
                        "<u>не</u>должно быть равно".
                    </p>
                    <p>
                        И это делается с помощью специального свойства <span class="blue">not</span>.
                    </p>
                    <p>
                        Оно прописывается перед вызовом функции-матчера, и меняет логику проверки на противоположную.
                    </p>
                    <pre>
                        <code class="js">
expect(что-то).not.матчер(что-то);
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример отрицания</h3>
                    <pre>
                        <code class="js">
function bestFlavor() {
    return 'картошка';
}

test('Лучший вкус - не кокос', function() {
    const flavor = bestFlavor();
    expect(flavor).not.toBe('кокос');
});
test('Лучший вкус - не банан', function() {
    const flavor = bestFlavor();
    expect(flavor).not.toBe('банан');
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Матчеры для чисел</h2>
                    <p>
                        К специфичным для проверки чисел матчерам, относятся матчеры диапазонов, которые
                        позволяют проверить, попадает ли полученное число в ожидаемый диапазон значений.
                    </p>
                    <p>
                        Это матчеры:
                    </p>
                    <ul>
                        <li><span class="blue">toBeGreaterThan()</span> - больше чем</li>
                        <li><span class="blue">toBeGreaterThanOrEqual()</span> - больше или равно чем</li>
                        <li><span class="blue">toBeLessThan()</span> - меньше чем</li>
                        <li><span class="blue">toBeLessThanOrEqual()</span> - меньше или равно чем</li>
                    </ul>
                </section>
                <section>
                    <h3>Пример диапазонных матчеров</h3>
                    <pre>
                        <code class="js">
function getRandomInt(min, max) {
    return Math.ceil(min) + Math.floor(Math.random() * max);
}

test('Случайное число из диапазона положительных чисел', function() {
    const min = 20;
    const max = 30;
    const value = getRandomInt(min, max);
    expect(value).toBeGreaterThanOrEqual(min);
    expect(value).toBeLessThanOrEqual(max);
});
test('Случайное число из диапазона отрицательных чисел', function() {
    const min = -50;
    const max = -10;
    const value = getRandomInt(min, max);
    expect(value).toBeGreaterThanOrEqual(min);
    expect(value).toBeLessThanOrEqual(max);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Проверка вещественных чисел</h2>
                    <p>
                        Из-за своей природы, в JavaScript нельзя надёжно сравнивать два вещественных числа. Поэтому
                        и матчер <span class="blue">toBe()</span> здесь не подходит.
                    </p>
                    <p>
                        Вещественные (дробные) числа нужно всегда сравнивать с помощью матчера
                        <span class="blue">toBeCloseTo()</span>!
                    </p>
                    <pre>
                        <code class="js">
test('0.1 плюс 0.2 не равно 0.3 в JS', function() {
    // Тест пройдёт, 0.1 + 0.2 действительно НЕ равно 0.3
    expect(0.1 + 0.2).not.toBe(0.3);
});
test('0.1 плюс 0.2 равно примерно 0.3', function() {
    // Такой тест будет работать
    expect(0.1 + 0.2).toBeCloseTo(0.3);
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Проверка строк по регулярным выражениям</h2>
                    <p>
                        Строки можно проверять на соответствие регулярному выражению через матчер
                        <span class="blue">toMatch()</span>.
                    </p>
                    <pre>
                        <code class="js">
function generateRandomName() {
    const surnames = ['Пётр', 'Владислав', 'Евгений', 'Марат', 'Николай', 'Валерий', 'Василий'];
    const lastnames = ['Мельчиков', 'Доргало', 'Крючочкин', 'Дикай', 'Ломоносов', 'Скорожевский', 'Вепрь', 'Степной'];
    const randomSurname = surnames[Math.floor(Math.random() * surnames.length)];
    const randomLastname = lastnames[Math.floor(Math.random() * lastnames.length)];
    return randomSurname + ' ' + randomLastname;
}
test('Имя состоит из двух слов', function() {
    const newName = generateRandomName();
    expect(newName).toMatch(/^[А-ЯЁ][а-яё]+ [А-ЯЁ][а-яё]+$/);
});
test('Тот же тест, только в профиль', function() {
    const pattern = new RegExp('^[А-ЯЁ][а-яё]+ [А-ЯЁ][а-яё]+$');
    const newName = generateRandomName();
    expect(newName).toMatch(pattern);
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Проверки для коллекций</h2>
                    <h3>Вхождение в коллекцию</h3>
                    <p>
                        С помощью матчера <span class="blue">toContain()</span> и <span class="blue">toContainEqual()</span>
                        проверяется вхождение элемента в коллекцию (массив, строку, или другое перечисление).
                    </p>
                    <p>
                        При использовании этого матчера, в <span class="blue">expect()</span> нужно передавать
                        само перечисление, а в <span class="blue">toContain()</span> - значение, наличие которого в
                        предыдущем перечислении нужно проверить.
                    </p>
                    <pre>
                        <code class="js">
const arr = [2, 53, 11, 8, 25];
function addToArr(value) {
    arr.push(value);
}
test('Добавление в массив работает корректно', function() {
    const newItem = 17;
    addToArr(newItem);
    expect(arr).toContain(newItem);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Проверка длины перечисления</h2>
                    <p>
                        Если нужно проверить количество элементов в перечислении, можно воспользоваться матчером
                        <span class="blue">toHaveLength()</span>, который проверяет значение свойства <i>length</i>.
                    </p>
                    <pre>
                        <code class="js">
function makeLongString(char, length) {
    return char.repeat(length);
}
test('Получается строка верной длины', function() {
    const desiredLength = 20;
    const resultStr = makeLongString('0', desiredLength);
    expect(resultStr).toHaveLength(desiredLength);
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Проверки объектов</h2>
                    <p>
                        Объекты можно проверять на наличие "под-объектов", или, если выразиться иначе, на соответствие
                        шаблона объекта.
                    </p>
                    <p>
                        Т.е. можно задать объект, и ожидать, что этот объект (его ключи и значения по ним), будет
                        содержаться внутри другого проверяемого объекта.
                    </p>
                    <p>
                        Это производится с помощью матчера <span class="blue">toMatchObject()</span>.
                    </p>
                </section>
                <section>
                    <h3>Пример с toMatchObject</h3>
                    <pre>
                        <code class="js">
const houseForSale = {
    bath: true,
    bedrooms: 4,
    kitchen: {
        amenities: ['плита', 'духовка', 'стиральная машина'],
        area: 20,
        wallColor: 'белый'
    },
};
    
test('the house has my desired features', function() {
    const desiredHouse = {
        bath: true,
        kitchen: {
            // Интересность
            amenities: expect.arrayContaining(['плита']),
            wallColor: expect.stringMatching(/белый|желтый/)
        }
    };
    expect(houseForSale).toMatchObject(desiredHouse);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Проверка наличия ключа</h2>
                    <p>
                        Матчер <span class="blue">toHaveProperty()</span> используется для проверки объекта
                        на наличие в нём указанного свойства (ключа).
                    </p>
                    <pre>
                        <code class="js">
// Тестируемый объект
const houseForSale = {
    bath: true,
    bedrooms: 4,
    kitchen: {
        amenities: ['плита', 'духовка', 'стиральная машина']
        area: 20,
        wallColor: 'белый',
        'nice.oven': true
    },
    'ceiling.height': 2
};

test('в этом доме есть всё что нужно', function() {
    // Обычный синтаксис
    expect(houseForSale).toHaveProperty('bath');
    expect(houseForSale).toHaveProperty('bedrooms', 4);

    expect(houseForSale).not.toHaveProperty('pool');

    // Используя точечную нотацию
    expect(houseForSale).toHaveProperty('kitchen.area', 20);
    expect(houseForSale).toHaveProperty('kitchen.amenities', ['плита', 'духовка', 'стиральная машина']);

    expect(houseForSale).not.toHaveProperty('kitchen.open');

});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Проверки исключений</h2>
                    <p>
                        Можно тестировать возникновение исключений при помощи матчера <span class="blue">toThrow()</span>. 
                    </p>
                    <p>
                        В параметрах можно указывать, какое конкретно исключение ожидается получить.
                    </p>
                    <p>
                        Для этого матчера используется несколько иной синтаксис чем раньше.
                    </p>
                    <p>
                        Функция, в которой ожидается происхождение исключения, должна быть вызвана внутри метода
                        <span class="blue">expect()</span>, вот по такому принципу:
                    </p>
                    <pre>
                        <code class="js">
expect(() => {
    // Вот здесь должен находиться код, в котором
    // Ожидается возникновение исключения
}).toThrow();
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример с toThrow()</h3>
                    <pre>
                        <code class="js">
let compile = function() {
    console.log([].join.call(arguments, ' -> '));
}
function drink(something) {
    if (something === 'чернила осьминога') {
        compile = function() {
            if (arguments.length === 3) {
                const includes = [].includes.bind(arguments);
                if (includes('волосы козы') && includes('гнилая груша') && includes('муравьиный яд')) {
                    throw Error('Ктулху');
                }
            }
        }
    } else {
        console.log('Bueeeh..');
    }
}

                
test('вызов Ктулху', function() {
    expect(function() {
        drink('чернила осьминога');
        compile('волосы козы', 'гнилая груша', 'муравьиный яд');
    }).toThrow('Ктулху');
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Снапшоты, или магия Jest</h2>
                    <blockquote>
                        <span class="purple">Снапшот</span> - это автоматически генерируемое значение ожидаемого
                        результата, полученное из фактического результата при первом запуске теста.
                    </blockquote>
                    <p>
                        Т.е. снапшоты можно использовать только тогда, когда вы уверены, что ваша функция написана
                        правильно и работает как надо.
                    </p>
                    <p>
                        Тогда можно даже не думать, какой должен быть ожидаемый результат: вы просто задаёте начальные
                        условия, и результат выводится и запоминается сам.
                    </p>
                </section>
                <section>
                    <h2>Области применения снапшотов</h2>
                    <p>
                        Но не стоит злоупотреблять снапшотами. Их рекомендуется использовать только тогда, когда
                        ожидаемым результатом является какая-нибудь массивная структура, которую долго прописывать
                        вручную.
                    </p>
                    <p>
                        Например, JSON объект, получаемый в качестве ответа от сервера по какому-нибудь API. Или
                        ветвь из DOM дерева.
                    </p>
                    <p>
                        Если вы ожидаете, что результатом функции должно быть простое значение,
                        типа <span class="blue">true</span>, то для этих целей снапшоты точно лучше не использовать.  
                    </p>
                </section>
                <section>
                    <h2>Виды снапшотов</h2>
                    <p>
                        Снапшоты в Jest бывают двух видов:
                    </p>
                    <ul>
                        <li>Внешние</li>
                        <li>Встроенные</li>
                    </ul>
                    <p>
                        Значения внешних снапшотов Jest хранит в отдельных файлах.
                    </p>
                    <p>
                        А значения встроенных снапшотов включаются прямо в код файла тестов.
                    </p>
                </section>
                <section>
                    <h2>Внешние снапшоты</h2>
                    <p>
                        Для использования внешнего снапшота предназначен матчер <span class="blue">toMatchSnapshot()</span>.
                    </p>
                    <p>
                        Самостоятельно нигде не нужно прописывать ожидаемого результата. Вы просто получаете
                        фактический результат и используете для него этот матчер:
                    </p>
                    <pre>
                        <code class="js">
expect(полученныйРезультат).toMatchSnapshot();
                        </code>
                    </pre>
                    <p>
                        И тогда, после первого запуска такого теста, в папке с этим тестом будет создана подпапка
                        __snapshots__, в которой появится файл с ожидаемым результатом для данного теста.
                    </p>
                </section>
                <section>
                    <h3>Пример с внешним снапшотом</h3>
                    <pre>
                        <code class="js">
// Тестируемая функция
function getDataById(id) {
    if (id === 1) {
        return { name: "The Great Gatsby", year: 1925, genre: "novel" };
    } else if (id === 2) {
        return { name: "Ulysses", year: 1918, genre: "modernist novel" };
    } else {
        return null;
    }
}

test('Получение данных по id', function() {
    const id = 1;
    const data = getDataById(id);
    expect(data).toMatchSnapshot();
});
                        </code>
                    </pre>
                    <pre>
                        <code class="js">
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`dwadad 1`] = `
Object {
    "genre": "novel",
    "name": "The Great Gatsby",
    "year": 1925,
}
`;
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Встроенные снапшоты</h2>
                    <p>
                        Для использования встроенных снапшотов может понадобится установка пакета <i>prettier</i>:
                    </p>
                    <pre>
                        <code class="bash">
npm i -D prettier
                        </code>
                    </pre>
                    <p>
                        Суть встроенных снапшотов аналогична, только они интегрируются прямо в текст вашего теста,
                        а не в отдельный файл.
                    </p>
                    <p>
                        Матчер для использования - <span class="blue">toMatchInlineSnapshot()</span>.
                    </p>
                    <pre>
                        <code class="js">
expect(полученныйРезультат).toMatchInlineSnapshot();
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример со встроенным снапшотом</h3>
                    <p>
                        Переделаем предыдущий пример под встроенные снапшоты:
                    </p>
                    <pre>
                        <code class="js">
test('Получение данных по id', function() {
    const id = 2;
    const data = getDataById(id);
    expect(data).toMatchInlineSnapshot();
});
                        </code>
                    </pre>
                    <p>
                        Стоит запустить этот тест, и немножко подождать, как...
                    </p>
                    <pre>
                        <code class="js">
test("Получение данных по id", function() {
    const id = 2;
    const data = getDataById(id);
    expect(data).toMatchInlineSnapshot(`
        Object {
        "genre": "modernist novel",
        "name": "Ulysses",
        "year": 1918,
        }
    `);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Обновление снапшота</h2>
                    <p>
                        После первого запуска, результат каждого нового запуска теста будет сравниваться с 
                        первым результатом.
                    </p>
                    <p>
                        Но если вам необходимо обновить снапшот (допустим, вы переделали тестируемую функцию),
                        то это выполняется следующей командой в терминале:
                    </p>
                    <pre>
                        <code class="js">
npm test -- --updateSnapshot
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Дополнительные матчеры</h2>
                    <p>
                        Если вам мало стандартных матчеров, то всегда можно дописать свои, с помощью функции
                        <span class="blue">expect.extend()</span>.
                    </p>
                    <p>
                        Или можно установить пакет с кучей неофициальных, поддерживаемых комьюнити, матчеров для Jest:
                    </p>
                    <p>
                        <a href="https://github.com/jest-community/jest-extended">Ссылка на расширения для матчеров</a>
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>setup и teardown</h2>
                    <p>
                        Не редко возникает ситуация, когда для выполнения теста нужна какая-то предварительная
                        инициализация. Или наоборот, после каждого теста требуется подчищать оставленный мусор.
                    </p>
                    <p>
                        Для этого в Jest есть 4 глобальных функции:
                    </p>
                    <ul>
                        <li><span class="blue">beforeAll()</span> - выполняется 1 раз перед всеми тестами</li>
                        <li><span class="blue">afterAll()</span> - выполняется 1 раз после всех тестов</li>
                        <li><span class="blue">beforeEach()</span> - выполняется каждый раз перед каждым тестом</li>
                        <li><span class="blue">afterEach()</span> - выполняется каждый раз после каждого теста</li>
                    </ul>
                    <p>
                        В эти функции передаётся функция, в которой уже и описываются все действия:
                    </p>
                    <pre>
                        <code class="js">
beforeAll(function() {
    // Действия
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Примеры c -All</h3>
                    <pre>
                        <code class="js">
const globalDatabase = null;

beforeAll(function() {
    // Инициализируем БД и
    // Добавляем в БД данные для тестирования
    globalDatabase = makeGlobalDatabase();
    globalDatabase.insert({testData: 'foo'});
    globalDatabase.insert({testData: 'bar'});
    globalDatabase.insert({testData: 'baz'});
});

afterAll(function() {
    // Удаляем все тестовые данные из БД
    globalDatabase.remove({testData: 'foo'});
    globalDatabase.remove({testData: 'bar'});
    globalDatabase.remove({testData: 'baz'});
});

test('Поиск на одно поле работает', function() {
    return globalDatabase.find('foo', {}, function(res) {
        expect(res.length).toBeGreaterThan(0);
    });
});

test('Поиск на несколько полей работает', function() {
    return globalDatabase.find(['foo', 'bar'], {}, function(res) {
        expect(res.length).toBeGreaterThan(0);
    });
});

                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример с afterEach()</h3>
                    <pre>
                        <code class="js">
const globalDatabase = makeGlobalDatabase();

function cleanUpDatabase(db) {
    db.cleanUp();
}

afterEach(function() {
    cleanUpDatabase(globalDatabase);
});

test('Поиск работает', function() {
    return globalDatabase.find('ret', {}, function(res) {
        expect(results.length).toBeGreaterThan(0);
    });
});

test('Добавление работает', function() {
    return globalDatabase.insert('veg', makeThing(), function(res) {
        expect(response.success).toBeTruthy();
    });
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Группировка тестов</h2>
                    <p>
                        С помощью глобальной функции <span class="blue">describe()</span> можно разбивать тесты на
                        группы.
                    </p>
                    <p>
                        Например, так обычно разбивают на группы тесты, относящиеся к разной функциональности.
                    </p>
                    <pre>
                        <code class="js">
describe('Описание группы тестов 1', function() {
    test('Тест 1 из группы 1', function() {
        // AAA
    });
    test('Тест 2 из группы 1', function() {
        // AAA
    });
});
describe('Описание группы тестов 2', function() {
    test('Тест 1 из группы 2', function() {
        // AAA
    });
    test('Тест 2 из группы 2', function() {
        // AAA
    });
    test('Тест 3 из группы 2', function() {
        // AAA
    });
})
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Вложенность</h2>
                    <p>
                        Функции <span class="blue">describe()</span> могут быть свободно вложены друг в друга.
                    </p>
                    <pre>
                        <code class="js">
describe('Группа 1', function() {
    describe('Подгруппа 1', function() {
        // Тесты подгруппы 1 группы 1
    });
    describe('Подгруппа 2', function() {
        describe('Под-подгруппа 1', function() {
            // Тесты под-подгруппы 1 подгруппы 2 группы 1
        });
        // Тесты подгруппы 2 группы 1
    });
    // Тесты группы 1
});
describe('Группа 2', function() {
    // Тесты группы 2
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример с группировкой</h3>
                    <pre>
                        <code class="js">
const binaryStringToNumber = function(binString) {
    if (!/^[01]+$/.test(binString)) {
        throw new CustomError('Not a binary number.');
    }
    return parseInt(binString, 2);
};
    
describe('Тесты функции преобразования битовой строки в число', function() {

    describe('Использование неправильной битовой строки', function() {

        test('Сравнение не чисел вызывает исключение CustomError', function() {
            expect(function() {
                binaryStringToNumber('abc')
            }).toThrowError(CustomError);
        });
    
        test('Лишние пробелы вызывают исключение CustomError', function() {
        expect(dunction() {
            binaryStringToNumber('  100')).toThrowError(CustomError);
        });
    });
    
    describe('Использование правильной битовой строки', function() {

        test('Возвращает корректное число', function() {
            expect(binaryStringToNumber('100')).toBe(4);
        });
    });
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Группировка с setup и teardown</h2>
                    <p>
                        Но помимо семантических отличий, у группировки тестов есть ещё и функциональные отличия.
                    </p>
                    <p>
                        В каждой группе <span class="blue">describe()</span> могут присутствовать свои 
                        функции <span class="blue">before-</span> и <span class="blue">after-</span>.
                    </p>
                    <p>
                        Если группы вложены в другие группы, то функции <span class="blue">before-</span> и
                        <span class="blue">after-</span> будут выполняться от верхних групп до самых внутренних,
                        все вместе.
                    </p>
                </section>
                <section>
                    <h3>Пример</h3>
                    <pre>
                        <code class="js">
class DataStorage {
    constructor(maxElements, locale) {
        this.maxElements = maxElements;
        this._count = 0;
        this._locale = locale;
        this._innerStorage = {array: []};
        this._blocked = true;
    }
    
    open() {
        this._blocked = false;
    }
    
    close() {
        this._blocked = true;
    }
    
    isOpen() {
        return !this._blocked;
    }
    
    addNext(value) {
        if (this._blocked || this._count === this.maxElements) {
            return false;
        }
        this._innerStorage.array.push(value);
        this._count++;
        return true;
    }
    
    addByKey(key, value) {
        if (this._blocked || this._innerStorage.hasOwnProperty(key) || this._count === this.maxElements) {
            return false;
        }
        this._innerStorage[key] = value;
        this._count++;
        return true;
    }
    
    isEmpty() {
        return this._count === 0;
    }
    
    clearAllData() {
        if (this._blocked) {
            return false;
        }
        this._innerStorage = {array: []};
        this._count = 0;
        return true;
    }
}
    
    
describe('Тестирование класса DataStorage', function() {
    
    let storage;
    
    beforeAll(function() {
        const locale = 'ru-RU';
        const maxElements = 5;
        storage = new DataStorage(maxElements, locale);
    });
    
    test('По умолчанию хранилище закрыто', function() {
        expect(storage.isOpen()).toBeFalsy();
    });
    
    describe('Закрытое хранилище', function() {
    
        afterEach(function() {
            storage.close();
        });
    
        test('Нельзя добавлять в массив', function() {
            const testValue = 22;
            const result = storage.addNext(testValue);
            expect(result).toBeFalsy();
            expect(storage._count).toBe(0);
        });
    
        test('Нельзя добавлять по ключу', function() {
            const testKey = 'alpha';
            const testValue = 22;
            const result = storage.addByKey(testKey, testValue);
            expect(result).toBeFalsy();
            expect(storage._count).toBe(0);
        });
    
        test('Нельзя очистить', function() {
            const result = storage.clearAllData();
            expect(result).toBeFalsy();
            expect(storage._count).toBe(0);
        });
    
        test('Можно открыть', function() {
            storage.open();
            expect(storage.isOpen()).toBeTruthy();
        });
    });
    
    describe('Открытое хранилище', function() {
    
        beforeEach(function() {
            storage.open();
        });
    
        test('Добавление в массив', function() {
            const testValue = 432;
            const currentCount = storage._count;
            storage.addNext(testValue);
            expect(storage._count).toBe(currentCount + 1);
            expect(storage._innerStorage.array[0]).toBe(testValue);
        });
    
        test('Добавление по ключу', function() {
            const testKey = 'echo';
            const testValue = 432;
            const currentCount = storage._count;
            storage.addByKey(testKey, testValue);
            expect(storage._count).toBe(currentCount + 1);
            expect(storage._innerStorage[testKey]).toBe(testValue);
        });
    
        test('Можно закрыть', function() {
            const countBeforeClosing = storage._count;
            storage.close();
            expect(storage.isOpen()).toBeFalsy();
            expect(storage._count).toBe(countBeforeClosing);
        });
    
        describe('Хранилище с данными', function() {
    
            beforeEach(function() {
                storage.clearAllData();
                storage.addNext('четверг');
                storage.addNext('пятница');
                storage.addByKey('interval', 7);
            });
        
            test('Очистка удаляет все данные', function() {
                const result = storage.clearAllData();
                expect(result).toBeTruthy();
                expect(storage._count).toBe(0);
            });
        
            test('Нельзя добавить повторяющийся ключ', function() {
                const testKey = 'interval';
                const testValue = 14;
                const currentCount = storage._count;
                const result = storage.addByKey(testKey, testValue);
                expect(result).toBeFalsy();
                expect(storage._count).toBe(currentCount);
            });
        });
    
        describe('Хранилище переполнено', function() {
    
            beforeAll(function() {
                storage.clearAllData();
                for (let i = 0; i < storage.maxElements; ++i) {
                storage.addNext(i);
                }
            });
        
            test('Нельзя больше добавлять в массив', function() {
                const testValue = 22;
                const currentCount = storage._count;
                const result = storage.addNext(testValue);
                expect(result).toBeFalsy();
                expect(storage._count).toBe(currentCount);
            });
        
            test('Нельзя больше добавлять по ключу', function() {
                const testKey = 'alpha';
                const testValue = 22;
                const currentCount = storage._count;
                const result = storage.addByKey(testKey, testValue);
                expect(result).toBeFalsy();
                expect(storage._count).toBe(currentCount);
            });
    
        });
    });
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Data-driven тесты</h2>
                    <p>
                        Data-driven тесты - тесты управляемые данными. Это когда множество тестов строится по одному
                        и тому же сценарию и отличаются только данными начальных параметров.
                    </p>
                    <p>
                        Например, функцию деления можно проверить не только на 2 числах, а на наборе из отрицательных,
                        положительных, с нулем, и т.д. Но проверка всегда будет строится одним и тем же образом -
                        отличаться будут только входные параметры и ожидаемый результат.
                    </p>
                </section>
                <section>
                    <h2>Синтаксис Data-driven тестов</h2>
                    <p>
                        Для функции <span class="blue">test</span> вызывается дополнительный метод
                        <span class="blue">each()</span>, в который передается массив из массивов параметров теста:
                    </p>
                    <pre>
                        <code class="js">
test.each([
    [один набор параметров],
    [второй набор параметров],
    ...
])('Описание теста', function(имена для параметров) {

});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Вместо этого</h2>
                    <p>
                        Вместо того, чтобы писать несколько одинаковых тестов:
                    </p>
                    <pre>
                        <code class="js">
test('Деление 8 на 2', function() {
    const a = 8;
    const b = 2;
    const expectedResult = 4;
    const result = a / b;
    expect(result).toBeCloseTo(expectedResult);
});
test('Деление -11 на 3', function() {
    const a = -11;
    const b = 3;
    const expectedResult = 3.666666;
    const result = a / b;
    expect(result).toBeCloseTo(expectedResult);
});
test('Деление -20 на -5', function() {
    const a = -20;
    const b = -5;
    const expectedResult = 4;
    const result = a / b;
    expect(result).toBeCloseTo(expectedResult);
});
test('Деление -200 на 0', function() {
    const a = -200;
    const b = 0;
    const expectedResult = Infinity;
    const result = a / b;
    expect(result).toBeCloseTo(expectedResult);
});
test('Деление 0 на 13', function() {
    const a = 0;
    const b = 13;
    const expectedResult = 0;
    const result = a / b;
    expect(result).toBeCloseTo(expectedResult);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Вот это</h2>
                    <p>
                        Можно написать один data-driven тест, который будет аналогичен предыдущим пяти тестам:
                    </p>
                    <pre>
                        <code class="js">
test.each([
    [8, 2, 4],
    [-11, 3, -3.666666],
    [-20, -5, 4],
    [-200, 0, -Infinity],
    [0, 13, 0]
])('Деление чисел', function(a, b, expectedResult) {
    const result = a / b;
    expect(result).toBeCloseTo(expectedResult);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Data-driven группы</h2>
                    <p>
                        По такому же принципу можно делать управляемые данными группы через <span class="blue">describe</span>:
                    </p>
                    <pre>
                        <code class="js">
describe.each([
    [[1, 2, 3, 4, 5, 6], 4],
    [['str1', 'str2', 'str3', 'str4', 'str5', 'str6'], 'str4']
])('Тестирование функций Array для разных типов', function(array, value) {

    test('Функция поиска', function() {
        const result = array.find((el) => el === value);
        expect(result).toBeDefined();
    });

    test('Функция фильтрации', function() {
        const result = array.filter((el) => el !== value);
        expect(result).toMatchSnapshot();
    });

    test('Функция проверки вхождения', function() {
        const result = array.includes(value);
        expect(result).toBeTruthy();
    });

});
                        </code>
                    </pre>
                    <p>
                        Запустите этот код, и посмотрите, что будет со снапшотом для второго теста.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Тестирование асинхронного кода</h2>
                    <p>
                        Тестирование асинхронных функций - нетривиальная задачка. Ведь прежде чем выполнится
                        асинхронная операция, сама функция теста уже завершится.
                    </p>
                    <pre>
                        <code class="js">
// Этот тест не будет работать
test('Получение арахисового масла', function() {
    function callback(data) {
        expect(data).toBe('арахисовое масло');
    }
    // Асинхронная функция
    fetchData(callback);
});
                        </code>
                    </pre>
                    <p>
                        Но в Jest всё предусмотрено, и существуют разные механизмы для тестирования асинхронных
                        функций с коллбэками, через промисы, или async/await.
                    </p>
                </section>
                <section>
                    <h2>Браузерные запросы в тестах</h2>
                    <p>
                        Небольшая ремарка: тесты Jest запускаются в NodeJS, а в NodeJS не существует глобальной функции
                        fetch (как и объекта XMLHttpRequest). Чтобы можно было их использовать, нужно установливать
                        дополнительные пакеты.
                    </p>
                    <p>
                        Для использования XMLHttpRequest: пакет xmlhttprequest.
                    </p>
                    <pre>
                        <code class="bash">
npm i -D xmlhttprequest
                        </code>
                    </pre>
                    <p>
                        Для использования fetch: пакет isomorphic-fetch.
                    </p>
                    <pre>
                        <code class="bash">
npm i -D isomorphic-fetch
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Коллбэк done</h2>
                    <p>
                        Простейший вариант тестирования асинхронности - использование дополнительного параметра
                        функции теста - коллбэка <span class="blue">done</span>. Этот коллбэк нужно просто вызвать
                        в том месте, где асинхронный тест должен завершиться.
                    </p>
                    <p>
                        Иначе говоря, тест не будет считаться завершенным, пока коллбэк <span class="blue">done</span>
                        не будет вызван.
                    </p>
                    <pre>
                        <code class="js">
    // Этот тест не будет работать
    test('Получение арахисового масла', function() {
        function callback(data) {
            expect(data).toBe('арахисовое масло');
        }
        // Асинхронная функция
        fetchData(callback);
    });
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Пример с done</h3>
                    <pre>
                        <code class="js">
// Рабочий тест
test('Получение арахисового масла', function() {
    function callback(data) {
        expect(data).toBe('арахисовое масло');
        // В месте логического завершения теста вызываем коллбэк done
        done();
    }
    // Асинхронная функция
    fetchData(callback);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h3>Обещание когда-нибудь выполнить тест</h3>
                    <p>
                        Если тестируемая асинхронная функция возвращает промис, то тест можно оформить как
                        цепочку промисов и вернуть последний промис как возвращаемое значение функции теста.
                        И тогда никакой коллбэк <span class="blue">done()</span> больше не нужен.
                    </p>
                    <p>
                        С предыдущим примером это будет выглядеть вот так:
                    </p>
                    <pre>
                        <code class="js">
test('Получение арахисового масла', function() {
    // Возвращаем из теста цепочку промисов
    return fetchData().then(data => {
        expect(data).toBe('арахисовое масло');
    });
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Матчеры для промисов</h2>
                    <p>
                        Запись такого теста с промисами можно упростить, используя специальные матчеры
                        <span class="blue">resolves</span> и <span class="blue">rejects</span>:
                    </p>
                    <pre>
                        <code class="js">
test('Получение арахисового масла', function() {
    return expect(fetchData()).resolves.toBe('арахисовое масло');
});
test('Масла больше нет', function() {
    eatAllPeanutButter();
    return expect(fetchData()).rejects.toMatch('error');
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Пример</h2>
                    <pre>
                        <code class="js">
describe('Тестирование асинхронных запросов', function() {

    test('Запрос на получение фрукта', function() {
        return expect(fetchData('fruits')).resolves.toBe('apricot');
    });
    
    test.each([
        ['diamonds'],
        ['phones'],
        ['combs'],
        ['drug']
    ])('Запрос на получение того, чего нет', function(item) {
        return expect(fetchData(item)).resolves.toBe('nothing');
    });
    
    // Повышенный уровень опасности взрыва мозга!
    test.each('Запросы на получение овощей, фруктов и сладостей вместе', function() {
        return expect(
            Promise.all([
                fetchData('veggies'),
                fetchData('fruits'),
                fetchData('sweets')
            ]).then(function(results) {
                return results.join(', ');
            })
        ).toBe('potato, apricot, candys');
    });
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Запуск лишь одного теста</h2>
                    <p>
                        Если вы хотите быстро запустить всего один тест, пропустив все остальные, можно
                        временно поменять его определение с <span class="blue">test</span> на
                        <span class="blue">test.only</span>.
                    </p>
                    <p>
                        Тогда, при следующем запуске тестов (через <span class="turquoise">npm test</span>, например),
                        из всего файла будет запущен на выполнение только один тест.
                    </p>
                    <pre>
                        <code class="js">
test.only('Только один', function() {
    expect(-Infinity).not.toBe(+Infinity);
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Пропуск тестов</h2>
                    <p>
                        Также можно пропускать выбранные тесты. Если нужно временно отключить тест, вместо того,
                        чтобы удалять его код или помещать всё в комментарий, необходимо лишь
                        поменять его определение с <span class="blue">test</span> на <span class="blue">test.skip</span>.
                    </p>
                    <pre>
                        <code class="js">
test.skip('Вы меня больше не увидете...', function() {
    expect(Infinity).toBe(0);
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Моки</h2>
                    <p>
                        Часто весь код бывает очень сильно переплетён между собой и связан с какими-то внешними зависимостями.
                        В функции вы можете обращаться к другой функции, которая обращается к третьей функции, и т.д.
                    </p>
                    <p>
                        Но правильные юнит тесты должны проверять работоспособность лишь одного фактического действия,
                        одной функции.
                    </p>
                    <p>
                        Тогда как проверить только эту первую функцию без участия всех внутренних?
                    </p>
                    <p>
                        На помощь приходят <span class="purple">Моки</span>.
                    </p>
                    <p>
                        <span class="purple">Мок</span> - это подставная функция или объект. Мок внедряют в тестируемую
                        функцию, и она использует нашу подставную функцию вместо настоящей.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Спаи</h2>
                    <p>
                        Спаи - это засланные в функции шпионы.
                    </p>
                    <p>
                        Установив на функцию шпиона можно отслеживать все процессы, связанные с этой функцией.
                    </p>
                    <p>
                        Спаи позволяют отслеживать сколько раз была вызвана функция, какие параметры передавались
                        в неё при каждом вызове, какие значения она возвращала и т.д.
                    </p>
                    <p>
                        Конечно же, они используются для целей тестирования, чтобы можно было писать связанные с
                        вызовом функций проверки: была ли вызвана функция или нет; вернула функция правильное значение,
                        или нет; была ли функция вызвана действительно 2 раза, и т.д. в этом духе.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Моки и спаи в Jest</h2>
                    <p>
                        В Jest моки и спаи совмещены.
                    </p>
                    <p>
                        Любой мок имеет встроенную функциональность спая.
                    </p>
                    <p>
                        Но можно делать и чистых спаев - без функциональности моков.
                    </p>
                    <p>
                        Поэтому мы начнём с чистых спаев.
                    </p>
                </section>
                <section>
                    <h2>Спаи в Jest</h2>
                    <p>
                        В Jest спаями можно делать только <u>методы</u> (функции внутри объекта). При импорте модулей
                        так обычно и происходит, все функции инкапсулируются в импортируемом объекте модуля, или классе.
                    </p>
                    <p>
                        Для регистрации спая используется функция <span class="blue">jest.spyOn()</span>.
                    </p>
                    <pre>
                        <code class="js">
jest.spyOn(object, 'method');
                        </code>
                    </pre>
                    <p>
                        Первый параметр - <i>object</i> - это объект, внутри которого находится функция, за которой
                        нужно следить.
                    </p>
                    <p>
                        Второй параметр - <i>'method'</i> - строка с названием отслеживаемой функции.
                    </p>
                </section>
                <section>
                    <h3>Пример регистрации спая</h2>
                    <p>
                        Допустим, имеется объект <i>myModule</i> с методом <i>buySomething()</i>, который
                        вызывает внутри себя метод <i>soldSomething()</i>:
                    </p>
                    <pre>
                        <code class="js">
const myModule = {
    soldSomething: function() {
        if (arguments.length === 0) {
            return false;
        }
        console.log('И что же мы продаём?');
        console.log('Мы продаём:');
        for (const item of arguments) {
            console.log(item);
        }
        return true;
    },
    buySomething: function() {
        const itemsToSold = ['Велосипед', 'Телевизор', 'Холодильник', 'Машина', 'Дача', 'Квартира'];
        const solded = [];
        const buyedItems = [];
        console.log('И что же мы покупаем?');
        if (arguments.length === 0) {
            console.log('Мы покупаем баобаб!');
            itemsToSold.forEach((item) => solded.push(item));
            buyedItems.push('Баобаб вот такой ширины!');
        } else {
            console.log('Мы покупаем:');
            for (let i = 0; i < arguments.length; ++i) {
                console.log(arguments[i]);
                if (i < itemsToSold.length) {
                    solded.push(itemsToSold[i]);
                }
                buyedItems.push(arguments[i]);
            }
        }
        myModule.soldSomething(...solded);
        return buyedItems;
    }
}

test('Иии?', function() {
    // Вешаем шпиона на функцию myModule.soldSomething()
    jest.spyOn(myModule, 'soldSomething');
    // Продолжаем тест
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Слежка</h2>
                    <p>
                        Вызов функции <span class="blue">spyOn()</span> регстрирует шпиона на заданной функции.
                    </p>
                    <p>
                        Но что это даёт?
                    </p>
                    <p>
                        Это даёт возможность использовать на отслеживаемой функции целый набор разнообразных
                        функций-матчеров для слежки за её использованием.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Матчеры для спаев</h2>
                    <p>
                        Для работы со спаями через <span class="blue">expect()</span> есть целая куча функций:
                    </p>
                    <ul>
                        <li><span class="blue">toHaveBeenCalled()</span></li>
                        <li><span class="blue">toHaveBeenCalledTimes()</span></li>
                        <li><span class="blue">toHaveBeenCalledWith()</span></li>
                        <li><span class="blue">toHaveBeenLastCalledWith()</span></li>
                        <li><span class="blue">toHaveBeenNthCalledWith()</span></li>
                        <li><span class="blue">toHaveReturned()</span></li>
                        <li><span class="blue">toHaveReturnedTimes()</span></li>
                        <li><span class="blue">toHaveReturnedWith()</span></li>
                        <li><span class="blue">toHaveLastReturnedWith()</span></li>
                        <li><span class="blue">toHaveNthReturnedWith()</span></li>
                    </ul>
                </section>
                <section>
                    <h2>Контроль наличия вызова</h2>
                    <p>
                        Проверить, была ли вызвана функция в принципе, можно с помощью матчера
                        <span class="blue">toHaveBeenCalled()</span>.
                    </p>
                    <p>
                        С помощью матчера <span class="blue">toHaveBeenCalledTimes()</span> можно уточнить, сколько
                        раз мы ожидаем функция будет вызвана.
                    </p>
                    <pre>
                        <code class="js">
describe('Чтобы купить что-нибудь ненужное, нужно сначала продать что-нибудь ненужное', function() {

    test('Покупаем - значит продаём', function() {
        jest.spyOn(myModule, 'soldSomething');
        myModule.buySomething();
        expect(myModule.soldSomething).toHaveBeenCalled();
    });

    test('Покупаем 1 раз - значит продаём 1 раз', function() {
        jest.spyOn(myModule, 'soldSomething');
        myModule.buySomething();
        expect(myModule.soldSomething).toHaveBeenCalledTimes(1);
    });
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Проверка аргументов вызова</h2>
                    <p>
                        С помощью матчера <span class="blue">toHaveBeenCalledWith()</span> можно проверить, была
                        ли вызвана подозреваемая функция с заданными аргументами.
                    </p>
                    <pre>
                        <code class="js">
test('Хочешь купить гири - продавай велосипед', function() {
    jest.spyOn(myModule, 'soldSomething');
    myModule.buySomething('Гири');
    expect(myModule.soldSomething).toBeCalledWith('Велосипед');
});

test('Хочешь купить баобаб - продавай всё, что есть', function() {
    jest.spyOn(myModule, 'soldSomething');
    myModule.buySomething();
    expect(myModule.soldSomething).toBeCalledWith(
        'Велосипед', 'Телевизор', 'Холодильник', 'Машина', 'Дача', 'Квартира'
    );
})
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Проверка возвращаемого значения</h2>
                    <p>
                        Матчер <span class="blue">toHaveReturnedWith()</span> позволяет проверить, какое значение
                        было возвращено из отслеживаемой функции.
                    </p>
                    <pre>
                        <code class="js">
test('Продажа совершается успешно', function() {
    jest.spyOn(myModule, 'soldSomething');
    myModule.buySomething('груша');
    expect(myModule.soldSomething).toHaveReturnedWith(true);
});

test('Получение купленных вещей', function() {
    jest.spyOn(myModule, 'buySomething');
    myModule.buySomething('чернила', 'какаду', 'удочка');
    expect(myModule.buySomething).toHaveReturnedWith(['чернила', 'какаду', 'удочка']);
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h3>Пример со спаями</h3>
                    <p>
                        Допустим, у нас есть следующий модуль:
                    </p>
                    <pre>
                        <code class="js">
export class Man {
    constructor(name) {
        this.name = name;
    }
    plantTree() {
        console.log('Man must plant a tree - ✓');
    }
    raiseSon() {
        console.log('Man must raise a son - ✓');
    }
    buildHouse() {
        console.log('Man must build a house - ✓');
    }
    liveMansLife() {
        this.plantTree();
        this.raiseSon();
        this.buildHouse();
    }
}
                        </code>
                    </pre>
                    <p>
                        Как протестировать, что мужчина действительно садит дерево, растит сына и строит дом?
                    </p>
                </section>
                <section>
                    <h3>Тесты по жизни</h3>
                    <pre>
                        <code class="js">
import {Man} from './life.js';

describe('Проверка жизни мужчины', function() {

    let man = null;

    beforeAll(function() {
        man = new Man('Piter');
        jest.spyOn(man, 'plantTree');
        jest.spyOn(man, 'raiseSon');
        jest.spyOn(man, 'buildHouse');
    });

    afterEach(function() {
        jest.resetAllMocks();
    });

    test('Посадил дерево', function() {
        man.liveMansLife();
        expect(man.plantTree).toHaveBeenCalledTimes(1);
    });

    test('Вырастил сына', function() {
        man.liveMansLife();
        expect(man.raiseSon).toHaveBeenCalledTimes(1);
    });

    test('Построил дом', function() {
        man.liveMansLife();
        expect(man.buildHouse).toHaveBeenCalledTimes(1);
    });

});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Сброс счётчиков спая</h2>
                    <p>
                        Все тесты в файле тестов, по умолчанию, выполняются последовательно друг за другом.
                    </p>
                    <p>
                        Если функция, за которой следит шпион, вызывается сразу в нескольких тестах, то счётчики
                        слежки будут общими между всеми тестами.
                    </p>
                    <p>
                        Это значит, что во втором тесте счётчик количества вызовов будет равен 2, а в третьем тесте -
                        уже 3.
                    </p>
                    <p>
                        Чтобы избежать подобных проблем, необходимо своевременно сбрасывать спаи.
                    </p>
                </section>
                <section>
                    <h2>Объект спая/мока</h2>
                    <p>
                        До этого мы использовали возможности шпионов, но не видили их самих. Настоло время увидеть
                        наших тайных агентов.
                    </p>
                    <p>
                        Объект спая/мока можно получить через возвращаемое значение функции <span class="blue">spyOn()</span>.
                    </p>
                    <pre>
                        <code class="js">
const spy = jest.spyOn(object, 'method');
                        </code>
                    </pre>
                    <p>
                        Это объект спая(мока). В нём хранится вся информация: сколько и как была вызвана отслеживаемая функция.
                    </p>
                    <p>
                        Полное описание этого объекта можно посмотреть
                        <a href="https://jestjs.io/docs/en/mock-function-api#mockfnmockclear">в официальной документации</a>.
                    </p>
                </section>
                <section>
                    <h2>Функции для сброса спая</h2>
                    <p>
                        В объекте спая есть 3 функции сброса:
                    </p>
                    <ul>
                        <li><span class="blue">mockClear()</span> - очищает счётчики вызова указанного спая</li>
                        <li><span class="blue">mockReset()</span> - делает то же, что mockClear, дополнительно
                            удаляя реализацию отслеживаемой функции (актуально для моков)
                        </li>
                        <li><span class="blue">mockRestore()</span> - делает то же, что mockReset, но дополнительно
                            восстанавливает реализацию отслеживаемой функции до момента подмены (актуально для моков)
                        </li>
                    </ul>
                    <pre>
                        <code class="js">
const spy = jest.spyOn(object, 'method');
spy.clearMock();
                        </code>
                    </pre>
                    <p>
                        Эти функции часто помещают в блоки <span class="blue">before-after</span>, чтобы для каждого
                        теста использовались чистенькие шпионы.
                    </p>
                </section>
                <section>
                    <h2>Глобальный сброс</h2>
                    <p>
                        По аналогии с предыдущими функциями, есть 3 функции, которые делают то же самое, только
                        сразу для всех спаев и моков в файле. Их удобно использовать, т.к. не требуется наличия
                        объекта спая/мока.
                    </p>
                    <ul>
                        <li><span class="blue">jest.clearAllMocks()</span></li>
                        <li><span class="blue">jest.resetAllMocks()</span></li>
                        <li><span class="blue">jest.restoreAllMocks()</span></li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Моки в Jest</h2>
                    <p>
                        Моки имеют всю функциональность спаев, но добавляют к указанной функции свою реализацию,
                        вместо оригинальной.
                    </p>
                    <p>
                        Мок можно создать несколькими способами.
                    </p>
                    <p>
                        Поверх спая, используя метод <span class="blue">mockImplementation()</span>:
                    </p>
                    <pre>
                        <code class="js">
jest.spyOn(object, 'method').mockImplementation(function() {
    // Фальшивая реализация для object.method
});
                        </code>
                    </pre>
                    <p>
                        Или с помощью более простой записи с функцией <span class="blue">jest.fn()</span>:
                    </p>
                    <pre>
                        <code class="js">
object.method = jest.fn(function() {
    // Фальшивая реализация для object.method
});
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>Использование моков</h2>
                    <p>
                        Моки используются, чтобы заменить реальные зависимости тестируемой функции на наши
                        подставные, в которых мы уверены:
                    </p>
                    <pre>
                        <code class="js">
function longAndComplexQueryToDatabase() {
    const types = ['el', 'qu', 're', 'co'];
    types.forEach((value, index) => {
        if (value.length === index) {
            value = value.repeat(12);
            let codes = [];
            for (const char of value) {
                codes.push(char.charCodeAt(0));
            }
            return codes
                .filter((n) => n % 2)
                .map((n) => n += 5 - Math.random() * 10)
                .reduce((result, n) => result += n);
        }
    });
}
    
function checkDatabaseCount() {
    let num = longAndComplexQueryToDatabase();
    if (num > 1000) {
        return true;
    } else {
        return false;
    }
}

test('Проверка заполненности БД', function() {
    longAndComplexQueryToDatabase = jest.fn(function() {
        return 2000;
    });
    const result = checkDatabaseCount();
    expect(result).toBeTruthy();
});

test('Проверка заполненности БД', function() {
    longAndComplexQueryToDatabase = jest.fn(function() {
        return 400;
    });
    const result = checkDatabaseCount();
    expect(result).toBeFalsy();
});
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Доступ к приватным элементам</h2>
                    <h3>Пакет Rewire</h3>
                </section>
            </section>
            <section>
                <section>
                    <h2>Демонстрация</h2>
                    <ul>
                        <li><a href="../../completed/5/">Задание 5</a></li>
                        <li><a href="../../completed/6/">Задание 6</a></li>
                        <li><a href="../../completed/1/">Просто так</a></li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h2>Покрытие кода</h2>
                    <pre>
                        <code class="bash">
npm test -- --coverage
                        </code>
                    </pre>
                </section>
            </section>
		</div>
	</div>

	<aside id="presentable-icon" class="cpp">
		<a title="Содержание лекции" href="#/0/1">
			<i class="fa fa-list-ul fa-2x controls"></i>
		</a>
	</aside>
	<aside id="presentable-icon-close">
		<a title="К списку материалов" href="../../index.html#/1">
			<i class="fa fa-times fa-2x controls"></i>
		</a>
	</aside>
	<aside id="presentable-theme-picker">
		<div id="hidden-bar" class="invisible">
			<div>
				<div data-theme="beige" class="theme-circle theme-beige"></div>
				<div data-theme="black" class="theme-circle theme-black"></div>
				<div data-theme="blood" class="theme-circle theme-blood"></div>
				<div data-theme="league" class="theme-circle theme-league"></div>
				<div data-theme="moon" class="theme-circle theme-moon"></div>
				<div data-theme="night" class="theme-circle theme-night"></div>
				<div data-theme="serif" class="theme-circle theme-serif"></div>
				<div data-theme="simple" class="theme-circle theme-simple"></div>
				<div data-theme="sky" class="theme-circle theme-sky"></div>
				<div data-theme="solarized" class="theme-circle theme-solarized"></div>
				<div data-theme="white" class="theme-circle theme-white"></div>
			</div>
		</div>
		<div id="selected-theme" class="theme-circle"></div>
	</aside>

	<script src="../../js/bundle.min.js"></script>
</body>

</html>